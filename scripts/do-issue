#!/usr/bin/env bash
#
# do-issue - Start working on a GitHub issue with git worktree and Claude Code
#
# Usage: do-issue <issue-url-or-number> [options]
#
# Options:
#   --repo, -r <owner/repo>    Repository (default: from git remote)
#   --base, -b <branch>        Base branch (default: main or master)
#   --worktree-dir, -w <dir>   Worktree directory (default: ~/worktrees)
#   --no-init                  Skip init.sh execution
#   --dry-run                  Show what would be done without executing
#   --help, -h                 Show this help
#

set -euo pipefail

VERSION="1.6.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Defaults
WORKTREE_DIR="$HOME/.worktrees"
BASE_BRANCH=""
REPO=""
NO_INIT=false
DRY_RUN=false
FAST_MODE=true
ISSUE_INPUT=""

# ============================================================================
# Helper functions
# ============================================================================

log_info() {
    echo -e "${BLUE}$1${NC}"
}

log_success() {
    echo -e "${GREEN}$1${NC}"
}

log_warn() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_error() {
    echo -e "${RED}âŒ $1${NC}" >&2
}

die() {
    log_error "$1"
    exit 1
}

show_version() {
    echo "do-issue v$VERSION"
}

show_help() {
    show_version
    cat << 'EOF'

Start working on a GitHub issue with git worktree and Claude Code

Usage: do-issue <issue-url-or-number> [options]

Arguments:
  <issue-url-or-number>    GitHub issue URL or issue number
                           Examples: 123, https://github.com/owner/repo/issues/123

Options:
  --repo, -r <owner/repo>    Repository (default: detected from git remote)
  --base, -b <branch>        Base branch (default: main or master)
  --worktree-dir, -w <dir>   Directory for worktrees (default: ~/.worktrees)
  --no-init                  Skip init.sh execution
  --ai                       Use Claude AI for branch name (default: fast bash heuristics)
  --dry-run                  Show what would be done without executing
  --version, -v              Show version
  --help, -h                 Show this help

Examples:
  do-issue 123
  do-issue https://github.com/owner/repo/issues/123
  do-issue 123 --repo owner/repo --base develop
  do-issue 123 --dry-run
EOF
}

# ============================================================================
# Validation functions
# ============================================================================

check_dependencies() {
    if ! command -v git &> /dev/null; then
        die "git not found. Please install git."
    fi

    if ! command -v gh &> /dev/null; then
        die "gh CLI not found. Install: https://cli.github.com"
    fi

    if ! gh auth status &> /dev/null; then
        die "gh not authenticated. Run: gh auth login"
    fi

    if ! command -v claude &> /dev/null; then
        die "claude CLI not found. Please install Claude Code."
    fi

    if ! command -v jq &> /dev/null; then
        die "jq not found. Please install jq."
    fi
}

check_git_repo() {
    if ! git rev-parse --git-dir &> /dev/null; then
        die "Not in a git repository"
    fi
}

# ============================================================================
# Parsing functions
# ============================================================================

parse_issue_input() {
    local input="$1"

    # Check if it's a URL
    if [[ "$input" =~ ^https://github\.com/([^/]+)/([^/]+)/issues/([0-9]+) ]]; then
        REPO="${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
        ISSUE_NUMBER="${BASH_REMATCH[3]}"
    elif [[ "$input" =~ ^[0-9]+$ ]]; then
        ISSUE_NUMBER="$input"
        # Repo will be detected from git remote if not specified
    else
        die "Invalid issue format: $input. Use issue number or full GitHub URL."
    fi
}

detect_repo_from_remote() {
    if [[ -n "$REPO" ]]; then
        return
    fi

    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    if [[ -z "$remote_url" ]]; then
        die "Cannot detect repository. No 'origin' remote found. Use --repo flag."
    fi

    # Parse SSH format: git@github.com:owner/repo.git
    if [[ "$remote_url" =~ git@github\.com:([^/]+)/(.+?)(\.git)?$ ]]; then
        REPO="${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    # Parse HTTPS format: https://github.com/owner/repo.git
    elif [[ "$remote_url" =~ https://github\.com/([^/]+)/(.+?)(\.git)?$ ]]; then
        REPO="${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    else
        die "Cannot parse repository from remote URL: $remote_url. Use --repo flag."
    fi
}

detect_base_branch() {
    if [[ -n "$BASE_BRANCH" ]]; then
        return
    fi

    # Try main first, then master
    if git show-ref --verify --quiet refs/heads/main 2>/dev/null; then
        BASE_BRANCH="main"
    elif git show-ref --verify --quiet refs/heads/master 2>/dev/null; then
        BASE_BRANCH="master"
    else
        die "Cannot detect base branch. Neither 'main' nor 'master' exists. Use --base flag."
    fi
}

# ============================================================================
# Issue functions
# ============================================================================

fetch_issue() {
    log_info "ðŸ” Fetching issue #$ISSUE_NUMBER from $REPO..."

    ISSUE_JSON=$(gh api "repos/$REPO/issues/$ISSUE_NUMBER" 2>/dev/null) || \
        die "Issue #$ISSUE_NUMBER not found in $REPO"

    ISSUE_TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
    ISSUE_BODY=$(echo "$ISSUE_JSON" | jq -r '.body // ""')
    ISSUE_LABELS=$(echo "$ISSUE_JSON" | jq -r '[.labels[].name] | join(", ")')
    ISSUE_URL="https://github.com/$REPO/issues/$ISSUE_NUMBER"

    echo "   Title: $ISSUE_TITLE"
    if [[ -n "$ISSUE_LABELS" ]]; then
        echo "   Labels: $ISSUE_LABELS"
    fi
}

generate_branch_name() {
    log_info "ðŸ§  Generating branch name..."

    local start_time=$SECONDS

    if [[ "$FAST_MODE" == "true" ]]; then
        # Fast mode: bash heuristics
        local branch_type="feature"

        # Determine type from labels
        if [[ "$ISSUE_LABELS" =~ (bug|fix) ]]; then
            branch_type="fix"
        elif [[ "$ISSUE_LABELS" =~ (hotfix|critical) ]]; then
            branch_type="hotfix"
        elif [[ "$ISSUE_LABELS" =~ (docs|documentation) ]]; then
            branch_type="docs"
        elif [[ "$ISSUE_LABELS" =~ (refactor|tech-debt) ]]; then
            branch_type="refactor"
        fi

        # Generate short name from title
        local short_name
        short_name=$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | \
            sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//' | cut -c1-40)

        BRANCH_NAME="$branch_type/issue-$ISSUE_NUMBER-$short_name"
        local elapsed=$((SECONDS - start_time))
        log_success "   Branch: $BRANCH_NAME (${elapsed}s, fast)"
    else
        # Claude mode: AI-generated name
        local prompt="Git branch name for issue #$ISSUE_NUMBER: \"$ISSUE_TITLE\" (labels: $ISSUE_LABELS).
Format: {type}/issue-$ISSUE_NUMBER-{kebab-case-name}
Types: bug/fixâ†’fix, enhancementâ†’feature, hotfixâ†’hotfix, docsâ†’docs, defaultâ†’feature.
Reply with ONLY the branch name."

        # Disable skills for faster startup
        BRANCH_NAME=$(claude --print --model haiku --no-session-persistence \
            --disable-slash-commands "$prompt" 2>/dev/null) || \
            die "Failed to generate branch name with Claude"
        local elapsed=$((SECONDS - start_time))

        # Clean up the response (remove any whitespace, quotes, backticks)
        BRANCH_NAME=$(echo "$BRANCH_NAME" | tr -d '`"' | xargs)

        # Validate branch name format
        if [[ ! "$BRANCH_NAME" =~ ^(feature|fix|hotfix|refactor|docs)/issue-[0-9]+-[a-z0-9-]+$ ]]; then
            log_warn "Generated branch name doesn't match expected format: $BRANCH_NAME"
            # Fallback to simple format
            local short_name
            short_name=$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//' | cut -c1-40)
            BRANCH_NAME="feature/issue-$ISSUE_NUMBER-$short_name"
            log_info "   Using fallback: $BRANCH_NAME (${elapsed}s)"
        else
            log_success "   Branch: $BRANCH_NAME (${elapsed}s)"
        fi
    fi
}

# ============================================================================
# Worktree functions
# ============================================================================

create_worktree() {
    WORKTREE_PATH="$WORKTREE_DIR/$BRANCH_NAME"

    log_info "ðŸ“ Creating worktree..."
    echo "   Path: $WORKTREE_PATH"
    echo "   Base: $BASE_BRANCH"

    # Check if branch already exists
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME" 2>/dev/null; then
        # Find existing worktree for this branch
        local existing_worktree
        existing_worktree=$(git worktree list --porcelain | grep -A2 "^worktree " | \
            awk -v branch="$BRANCH_NAME" '/^worktree /{path=$2} /^branch refs\/heads\// && $2 ~ branch {print path}' | head -1)

        echo ""
        log_warn "Branch '$BRANCH_NAME' already exists."
        if [[ -n "$existing_worktree" ]]; then
            echo "   Existing worktree: $existing_worktree"
        fi
        echo ""
        echo "Options:"
        echo "  [u] Use existing worktree and continue"
        echo "  [n] Create new branch with different name"
        echo "  [d] Delete branch/worktree and recreate"
        echo "  [a] Abort"
        echo ""
        read -p "Choice: " choice
        case "$choice" in
            u|U)
                if [[ -n "$existing_worktree" ]]; then
                    WORKTREE_PATH="$existing_worktree"
                    log_info "   Using existing worktree: $WORKTREE_PATH"
                    return
                else
                    die "No existing worktree found for branch '$BRANCH_NAME'. Use [d] to delete and recreate."
                fi
                ;;
            n|N)
                # Generate new branch name with timestamp suffix
                local timestamp
                timestamp=$(date +%s | tail -c 5)
                BRANCH_NAME="${BRANCH_NAME}-${timestamp}"
                WORKTREE_PATH="$WORKTREE_DIR/$BRANCH_NAME"
                log_info "   New branch name: $BRANCH_NAME"
                ;;
            d|D)
                log_info "   Removing existing branch/worktree..."
                if [[ -n "$existing_worktree" ]]; then
                    git worktree remove --force "$existing_worktree" 2>/dev/null || rm -rf "$existing_worktree"
                fi
                git branch -D "$BRANCH_NAME" 2>/dev/null || true
                log_success "   âœ… Cleaned up"
                ;;
            *)
                die "Aborted by user"
                ;;
        esac
    fi

    # Check if worktree path already exists (without branch)
    if [[ -d "$WORKTREE_PATH" ]]; then
        echo ""
        log_warn "Worktree path already exists: $WORKTREE_PATH"
        echo ""
        read -p "What to do? [u]se existing / [d]elete and recreate / [a]bort: " choice
        case "$choice" in
            u|U|use)
                log_info "   Using existing worktree"
                return
                ;;
            d|D|delete)
                log_info "   Removing existing worktree..."
                git worktree remove --force "$WORKTREE_PATH" 2>/dev/null || rm -rf "$WORKTREE_PATH"
                git branch -D "$BRANCH_NAME" 2>/dev/null || true
                ;;
            *)
                die "Aborted by user"
                ;;
        esac
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        echo "   [DRY-RUN] Would run: git worktree add -b $BRANCH_NAME $WORKTREE_PATH $BASE_BRANCH"
        return
    fi

    # Create parent directory if needed
    mkdir -p "$(dirname "$WORKTREE_PATH")"

    # Fetch latest from remote
    git fetch origin "$BASE_BRANCH" --quiet 2>/dev/null || true

    # Create worktree with new branch
    git worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "origin/$BASE_BRANCH" || \
        git worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "$BASE_BRANCH" || \
        die "Failed to create worktree"

    log_success "   âœ… Worktree created"
}

run_init_script() {
    if [[ "$NO_INIT" == "true" ]]; then
        log_info "â­ï¸  Skipping init.sh (--no-init)"
        return
    fi

    local init_script="$WORKTREE_PATH/init.sh"

    if [[ ! -f "$init_script" ]]; then
        log_warn "init.sh not found, skipping initialization"
        return
    fi

    log_info "âš™ï¸  Running init.sh..."

    if [[ "$DRY_RUN" == "true" ]]; then
        echo "   [DRY-RUN] Would run: $init_script"
        return
    fi

    if ! (cd "$WORKTREE_PATH" && bash ./init.sh); then
        log_warn "init.sh exited with non-zero code"
    else
        log_success "   âœ… Done"
    fi
}

# ============================================================================
# Zellij integration
# ============================================================================

rename_zellij_tab() {
    local script_dir
    script_dir="$(dirname "$(readlink -f "$0")")"

    log_info "ðŸ“‘ Renaming zellij tab..."
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "   [DRY-RUN] Would run: zellij-rename-tab-to-issue-number \"$ISSUE_NUMBER\""
        return
    fi
    if "$script_dir/zellij-rename-tab-to-issue-number" "$ISSUE_NUMBER"; then
        log_success "   âœ… Tab renamed to #$ISSUE_NUMBER"
    fi
}

# ============================================================================
# Claude session
# ============================================================================

print_session_header() {
    local term_width
    term_width=$(tput cols 2>/dev/null || echo 80)

    # Minimum width for content
    local min_width=60
    [[ $term_width -lt $min_width ]] && term_width=$min_width

    # Convert home to ~
    local display_path="${WORKTREE_PATH/#$HOME/\~}"

    # Content lines
    local line1="Claude Code"
    local line2="Branch: $BRANCH_NAME"
    local line3="Issue: #$ISSUE_NUMBER - $ISSUE_TITLE"
    local line4="Path: $display_path"

    # Truncate long lines if needed
    local max_content_width=$((term_width - 4))  # 4 = "â”‚ " + " â”‚"
    [[ ${#line2} -gt $max_content_width ]] && line2="${line2:0:$((max_content_width - 3))}..."
    [[ ${#line3} -gt $max_content_width ]] && line3="${line3:0:$((max_content_width - 3))}..."
    [[ ${#line4} -gt $max_content_width ]] && line4="${line4:0:$((max_content_width - 3))}..."

    # Generate horizontal lines
    local h_line=""
    for ((i = 0; i < term_width - 2; i++)); do
        h_line+="â”€"
    done

    # Pad function
    pad_line() {
        local text="$1"
        local padding=$((term_width - 4 - ${#text}))
        printf "â”‚ %s%*s â”‚\n" "$text" "$padding" ""
    }

    echo ""
    printf "â•­%sâ•®\n" "$h_line"
    pad_line "$line1"
    printf "â”œ%sâ”¤\n" "$h_line"
    pad_line "$line2"
    pad_line "$line3"
    pad_line "$line4"
    printf "â•°%sâ•¯\n" "$h_line"
    echo ""
}

start_claude_session() {
    log_info "ðŸš€ Starting Claude Code session..."

    local initial_command="/feature-dev:feature-dev implement feature $ISSUE_URL"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo "   [DRY-RUN] Would run: cd $WORKTREE_PATH && claude --dangerously-skip-permissions \"$initial_command\""
        return
    fi

    print_session_header

    # Change to worktree directory and start Claude
    cd "$WORKTREE_PATH"
    exec claude --dangerously-skip-permissions "$initial_command"
}

# ============================================================================
# Argument parsing
# ============================================================================

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --repo|-r)
                REPO="$2"
                shift 2
                ;;
            --base|-b)
                BASE_BRANCH="$2"
                shift 2
                ;;
            --worktree-dir|-w)
                WORKTREE_DIR="$2"
                shift 2
                ;;
            --no-init)
                NO_INIT=true
                shift
                ;;
            --ai)
                FAST_MODE=false
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --version|-v)
                show_version
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            -*)
                die "Unknown option: $1. Use --help for usage."
                ;;
            *)
                if [[ -z "$ISSUE_INPUT" ]]; then
                    ISSUE_INPUT="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ISSUE_INPUT" ]]; then
        show_help
        exit 1
    fi
}

# ============================================================================
# Main
# ============================================================================

main() {
    parse_args "$@"

    echo -e "${BLUE}do-issue${NC} v$VERSION"
    echo ""

    check_dependencies
    check_git_repo
    parse_issue_input "$ISSUE_INPUT"
    rename_zellij_tab
    detect_repo_from_remote
    detect_base_branch

    fetch_issue
    generate_branch_name
    create_worktree
    run_init_script
    start_claude_session
}

main "$@"
